MySQL 的查询缓存对 Mysql 的函数不起作用

在 navicat 中 EXPLAIN 你的 SELECT 查询 ，可以让我们找到潜在的性能问题

当只要一行数据时使用 LIMIT 1 

为搜索字段建索引 

在 Join 表的时候使用相当类型的例，并将其索引 

避免 SELECT * 

尽可能的使用 NOT NULL 

Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击。但其不支持查询缓存。但据说版本5.1后支持了。 

固定长度的表会更快 

大的 DELETE 或 INSERT 语句 ，分开、间断 执行

选择正确的存储引擎：
MyISAM 适合大量查询
InnoDB 适合写，支持 事务。



索引类型：
普通索引：最基本的索引，没有任何限制
唯一索引：索引列的值必须唯一，但允许有空值
主键索引：特殊的唯一索引
多列索引：多个字段组成一个索引
全文索引：仅可用于 MyISAM 表

索引不会包含有 NULL 值得列
like '%aa%' 不会使用索引，like 'aa%' 会使用索引
不要在列上进行运算

索引方法：
Hash:不能使用范围查询
Btree:


事务回滚，是针对从 begin 开始的所有对数据库的操作，无论操作了几张表，都会自动删除产生的数据，必须为 InnoDB 类型

linux下，表名忽略大小写，数据库名、字段名 区分大小写
